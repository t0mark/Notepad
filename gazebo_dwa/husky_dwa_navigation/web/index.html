<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>ì¹´ì¹´ì˜¤ ì§€ë„ì™€ ë‚´ë¹„ ì—°ë™</title>
    <style>
        #map {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
        }
        #status {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
            font-weight: bold;
            z-index: 1;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        #controls {
            position: absolute;
            top: 10px;
            right: 10px;
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1;
            font-family: Arial, sans-serif;
        }
        #controls label {
            display: block;
            margin-bottom: 5px;
            font-size: 14px;
            font-weight: bold;
        }
        #controls input[type="range"] {
            width: 150px;
        }
        #controls .value-display {
            font-size: 12px;
            color: #666;
            margin-top: 2px;
        }
    </style>
    <script src="https://dapi.kakao.com/v2/maps/sdk.js?appkey=5aefe0539358793ca2935a52f01e03db&libraries=services"></script>
</head>
<body>
    <div id="status">GPS ì—°ê²° ëŒ€ê¸° ì¤‘...</div>
    <div id="controls">
        <label>ìº í¼ìŠ¤ Waypoints ê°„ê²©</label>
        <input type="range" id="distanceSlider" min="3" max="15" value="8" step="1">
        <div class="value-display" id="distanceValue">8m ê°„ê²©</div>
        
        <label style="margin-top: 10px;">ê³¡ì„  ì •ë°€ë„</label>
        <input type="range" id="curveSlider" min="3" max="15" value="8" step="1">
        <div class="value-display" id="curveValue">8Â° ê³¡ì„  ì„ê³„ê°’</div>
        
        <div style="font-size: 11px; color: #888; margin-top: 5px;">
            ìº í¼ìŠ¤ ìµœì í™”: 3m(ë§¤ìš°ì •ë°€) / 8m(ê¶Œì¥) / 15m(ì„±ê¹€)
        </div>
    </div>
    <div id="map"></div>

    <script>
        // âœ… ì „ë¶ëŒ€ ì¢Œí‘œë¡œ ì´ˆê¸°í™”
        var map = new kakao.maps.Map(document.getElementById('map'), {
            center: new kakao.maps.LatLng(35.8450893, 127.13304149999999), // ì „ë¶ëŒ€
            level: 3
        });

        var currentMarker = null;
        // âœ… íŒŒë€ ì •í™•ë„ ì› ë³€ìˆ˜ ì™„ì „ ì œê±°
        // var currentAccuracyCircle = null; (ì‚­ì œë¨)
        var destinationMarker = null;
        var routePolyline = null;
        var passedPolyline = new kakao.maps.Polyline({
            path: [],
            strokeWeight: 5,
            strokeColor: '#00FF00',
            strokeOpacity: 0.8,
            strokeStyle: 'solid',
            map: map
        });
        var destinationLatLng = null;
        var waypoints = [];
        var waypointMarkers = [];
        var currentWaypointIndex = 0;
        var geocoder = new kakao.maps.services.Geocoder();
        var ws = null;
        var waypointsWs = null;

        // âœ… GPS ê³ ì • ì œì–´ ë³€ìˆ˜
        var firstGpsReceived = false;
        
        // ğŸ“Š ìº í¼ìŠ¤ íŠ¹í™” Waypoints ì œì–´ ë³€ìˆ˜ë“¤
        var currentMinDistance = 8;  // ìº í¼ìŠ¤ í™˜ê²½ì— ë§ëŠ” ê¸°ë³¸ ê°„ê²©
        var currentCurveThreshold = 8; // ë” ë¯¼ê°í•œ ê³¡ì„  ê°ì§€
        
        // ìŠ¬ë¼ì´ë” ì´ë²¤íŠ¸ ì²˜ë¦¬
        document.getElementById('distanceSlider').addEventListener('input', function() {
            currentMinDistance = parseInt(this.value);
            document.getElementById('distanceValue').innerText = currentMinDistance + 'm ê°„ê²©';
        });
        
        document.getElementById('curveSlider').addEventListener('input', function() {
            currentCurveThreshold = parseInt(this.value);
            document.getElementById('curveValue').innerText = currentCurveThreshold + 'Â° ê³¡ì„  ì„ê³„ê°’';
        });

        function updateLocation(lat, lon) {
            if (!lat || !lon) return;
            var locPosition = new kakao.maps.LatLng(lat, lon);
            console.log("ğŸ“ í˜„ì¬ ìœ„ì¹˜ ì—…ë°ì´íŠ¸:", lat, lon);

            if (currentMarker) {
                currentMarker.setPosition(locPosition);
            } else {
                currentMarker = new kakao.maps.Marker({
                    position: locPosition,
                    map: map,
                    title: "í˜„ì¬ ìœ„ì¹˜"
                });
            }

            // âœ… íŒŒë€ ì •í™•ë„ ì› ê´€ë ¨ ì½”ë“œ ì™„ì „ ì œê±°
            // if (currentAccuracyCircle) { ... } (ëª¨ë“  ê´€ë ¨ ì½”ë“œ ì‚­ì œë¨)

            // âœ… ì²« GPS ìˆ˜ì‹  ì‹œì—ë§Œ ì§€ë„ ì¤‘ì‹¬ ì´ë™
            if (!firstGpsReceived) {
                map.setCenter(locPosition);
                firstGpsReceived = true;
                console.log("ğŸ¯ ì²« GPS ìˆ˜ì‹  ì™„ë£Œ - ì§€ë„ ì¤‘ì‹¬ ì„¤ì •ë¨");
                document.getElementById("status").innerText = "GPS ì—°ê²° ì™„ë£Œ! ì§€ë„ë¥¼ ììœ ë¡­ê²Œ ì›€ì§ì¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.";
            }

            checkWaypointPass(lat, lon);
        }

        function getRouteData(startPos, endPos) {
            var url = 'https://apis-navi.kakaomobility.com/v1/directions';
            url += '?origin=' + startPos.getLng() + ',' + startPos.getLat();
            url += '&destination=' + endPos.getLng() + ',' + endPos.getLat();
            url += '&priority=DISTANCE';  // ìµœë‹¨ê±°ë¦¬ ìš°ì„ 

            document.getElementById("status").innerText = "ê²½ë¡œ ê³„ì‚° ì¤‘...";

            fetch(url, {
                method: 'GET',
                headers: {
                    'Authorization': 'KakaoAK 0a115b0069642fd0547386e225798817'
                }
            })
            .then(response => response.json())
            .then(data => {
                console.log("ğŸ“¡ ì „ì²´ ê²½ë¡œ ë°ì´í„°:", data);
                
                if (!data.routes || data.routes.length === 0) {
                    console.error("âŒ ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
                    document.getElementById("status").innerText = "ê²½ë¡œë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
                    return;
                }

                waypoints = [];
                currentWaypointIndex = 0;
                passedPolyline.setPath([]);

                console.log("ğŸ“ sections ê°œìˆ˜:", data.routes[0].sections.length);
                console.log("ğŸ“ roads ê°œìˆ˜:", data.routes[0].sections[0].roads.length);

                // ğŸ“Š waypoints ê±°ë¦¬ ê¸°ë°˜ í•„í„°ë§ ì„¤ì • (ì‚¬ìš©ì ì„¤ì •ê°’ ì‚¬ìš©)
                var minDistance = currentMinDistance;
                var lastWaypoint = null;
                var totalVertexes = 0;
                var filteredCount = 0;
                var allVertexes = [];  // ëª¨ë“  vertexë¥¼ ì €ì¥í•˜ì—¬ ë§ˆì§€ë§‰ ì  ë³´ì¥

                // ëª¨ë“  vertex ìˆ˜ì§‘
                data.routes[0].sections[0].roads.forEach(function(road) {
                    for (let i = 0; i < road.vertexes.length; i += 2) {
                        var lng = road.vertexes[i];
                        var lat = road.vertexes[i + 1];
                        if (lng && lat) {
                            allVertexes.push(new kakao.maps.LatLng(lat, lng));
                            totalVertexes++;
                        }
                    }
                });

                console.log(`ğŸ“Š ì´ ${totalVertexes}ê°œ vertex ìˆ˜ì§‘ ì™„ë£Œ`);

                // ğŸ¯ ìº í¼ìŠ¤ íŠ¹í™” ê°ë„ ê¸°ë°˜ ì ì‘í˜• í•„í„°ë§
                var campusStats = {
                    straightSegments: 0,
                    gentleCurves: 0, 
                    sharpCurves: 0,
                    keyPoints: 0
                };
                
                var lastWaypoint = null;
                var filteredCount = 0;
                
                // ìº í¼ìŠ¤ í™˜ê²½ ë§ì¶¤ ì„ê³„ê°’
                const straightThreshold = currentCurveThreshold;      // 8ë„ ë¯¸ë§Œ: ì§ì„ 
                const gentleCurveThreshold = currentCurveThreshold * 2; // 8-16ë„: ì™„ë§Œí•œ ê³¡ì„   
                const sharpCurveThreshold = currentCurveThreshold * 3;  // 16-24ë„: ê¸‰ê³¡ì„ 
                
                const straightInterval = minDistance * 1.5;  // ì§ì„ : 12m ê°„ê²©
                const gentleCurveInterval = minDistance;     // ì™„ë§Œí•œ ê³¡ì„ : 8m ê°„ê²©
                const sharpCurveInterval = minDistance * 0.6; // ê¸‰ê³¡ì„ : 5m ê°„ê²©
                
                for (let i = 0; i < allVertexes.length; i++) {
                    var currentPoint = allVertexes[i];
                    var isFirstPoint = (i === 0);
                    var isLastPoint = (i === allVertexes.length - 1);
                    
                    // ì‹œì‘ì ê³¼ ëì ì€ í•­ìƒ í¬í•¨
                    if (isFirstPoint || isLastPoint) {
                        waypoints.push(currentPoint);
                        lastWaypoint = currentPoint;
                        filteredCount++;
                        campusStats.keyPoints++;
                        console.log(`ğŸ“ Waypoint ${waypoints.length}: ${currentPoint.getLat().toFixed(6)}, ${currentPoint.getLng().toFixed(6)} ${isLastPoint ? '(ëª©ì ì§€)' : '(ì¶œë°œì )'}`);
                        continue;
                    }
                    
                    if (lastWaypoint == null) continue;
                    
                    // ê±°ë¦¬ ê³„ì‚°
                    var distanceFromLast = haversineDistance(
                        lastWaypoint.getLat(), lastWaypoint.getLng(), 
                        currentPoint.getLat(), currentPoint.getLng()
                    );
                    
                    // ê³¡ë¥  ê³„ì‚° (ìµœì†Œ 3ê°œ ì ì´ ìˆì„ ë•Œ)
                    var curvature = 0;
                    var curveType = "unknown";
                    var requiredInterval = minDistance;
                    
                    if (waypoints.length >= 2 && i < allVertexes.length - 1) {
                        var prevPoint = waypoints[waypoints.length - 2];
                        var nextPoint = allVertexes[Math.min(i + 2, allVertexes.length - 1)]; // 2ì¹¸ ì•ì˜ ì ìœ¼ë¡œ ë” ì •í™•í•œ ê³¡ë¥  ê³„ì‚°
                        curvature = calculateCurvature(prevPoint, currentPoint, nextPoint);
                        
                        if (curvature < straightThreshold) {
                            curveType = "ì§ì„ ";
                            requiredInterval = straightInterval;
                        } else if (curvature < gentleCurveThreshold) {
                            curveType = "ì™„ë§Œí•œê³¡ì„ ";
                            requiredInterval = gentleCurveInterval;
                        } else {
                            curveType = "ê¸‰ê³¡ì„ ";
                            requiredInterval = sharpCurveInterval;
                        }
                    }
                    
                    // í¬í•¨ ì—¬ë¶€ ê²°ì •
                    var shouldInclude = false;
                    var reason = "";
                    
                    if (curvature > sharpCurveThreshold) {
                        // ê¸‰ê³¡ì„ ì€ ê±°ë¦¬ ê´€ê³„ì—†ì´ í¬í•¨
                        shouldInclude = true;
                        reason = `ê¸‰ê³¡ì„ (${curvature.toFixed(1)}Â°)`;
                        campusStats.sharpCurves++;
                    } else if (curvature > currentCurveThreshold && distanceFromLast >= (requiredInterval * 0.5)) {
                        // ì›í˜• ê³¡ì„  ê°ì§€: ì„ê³„ê°’ ì´ìƒ ê³¡ì„ ì—ì„œ ì ˆë°˜ ê°„ê²©ìœ¼ë¡œ ì›¨ì´í¬ì¸íŠ¸ ì¶”ê°€
                        shouldInclude = true;
                        reason = `ì›í˜•ê³¡ì„ (${curvature.toFixed(1)}Â°, ${distanceFromLast.toFixed(1)}m)`;
                        campusStats.gentleCurves++;
                    } else if (distanceFromLast >= requiredInterval) {
                        // ê° êµ¬ê°„ë³„ í•„ìš” ê°„ê²© ì´ìƒì¼ ë•Œ í¬í•¨
                        shouldInclude = true;
                        reason = `${curveType}(${distanceFromLast.toFixed(1)}m)`;
                        
                        if (curveType === "ì§ì„ ") campusStats.straightSegments++;
                        else if (curveType === "ì™„ë§Œí•œê³¡ì„ ") campusStats.gentleCurves++;
                    }
                    
                    if (shouldInclude) {
                        waypoints.push(currentPoint);
                        lastWaypoint = currentPoint;
                        filteredCount++;
                        
                        // ì¤‘ìš”í•œ ê³¡ì„ ì ë“¤ê³¼ ì²˜ìŒ/ë§ˆì§€ë§‰ ëª‡ ê°œë§Œ ìƒì„¸ ë¡œê·¸
                        if (filteredCount <= 3 || filteredCount > allVertexes.length - 3 || curvature > sharpCurveThreshold) {
                            console.log(`ğŸ“ Waypoint ${waypoints.length}: ${currentPoint.getLat().toFixed(6)}, ${currentPoint.getLng().toFixed(6)} [${reason}]`);
                        }
                    }
                }
                
                // ìº í¼ìŠ¤ ìµœì í™” í†µê³„
                console.log(`ğŸ“ ìº í¼ìŠ¤ ê²½ë¡œ ìµœì í™” ì™„ë£Œ:`);
                console.log(`   - ê¸°ë³¸ ê°„ê²©: ${minDistance}m, ê³¡ì„  ê°ë„: ${currentCurveThreshold}Â°`);
                console.log(`   - ì§ì„  êµ¬ê°„: ${campusStats.straightSegments}ê°œ (${straightInterval}m ê°„ê²©)`);
                console.log(`   - ì™„ë§Œí•œ ê³¡ì„ : ${campusStats.gentleCurves}ê°œ (${gentleCurveInterval}m ê°„ê²©)`);
                console.log(`   - ê¸‰ê³¡ì„ : ${campusStats.sharpCurves}ê°œ (${sharpCurveInterval}m ê°„ê²©)`);
                console.log(`   - í•µì‹¬ ì§€ì : ${campusStats.keyPoints}ê°œ`);
                
                var reductionRate = ((totalVertexes - waypoints.length) / totalVertexes * 100).toFixed(1);
                console.log(`ğŸ¯ ìµœì¢… ìµœì í™”: ${totalVertexes}ê°œ â†’ ${waypoints.length}ê°œ (${reductionRate}% ê°ì†Œ)`);
                
                if (waypoints.length > 1) {
                    const totalDistance = haversineDistance(waypoints[0].getLat(), waypoints[0].getLng(), waypoints[waypoints.length-1].getLat(), waypoints[waypoints.length-1].getLng());
                    const averageInterval = totalDistance / (waypoints.length - 1);
                    console.log(`ğŸ“ ì´ ê±°ë¦¬: ${(totalDistance/1000).toFixed(2)}km, í‰ê·  ê°„ê²©: ${averageInterval.toFixed(1)}m`);
                    
                    // ìº í¼ìŠ¤ ì£¼í–‰ì— ì í•©í•œì§€ í‰ê°€
                    if (averageInterval < 15 && waypoints.length < 50) {
                        console.log(`âœ… ìº í¼ìŠ¤ ììœ¨ì£¼í–‰ì— ìµœì í™”ë¨ (í‰ê· ê°„ê²© ${averageInterval.toFixed(1)}m)`);
                    } else if (averageInterval > 20) {
                        console.log(`âš ï¸ ë„ˆë¬´ ì„±ê¸´ ê²½ë¡œ - ì •ë°€ë„ í–¥ìƒ ê¶Œì¥`);
                    }
                }

                console.log("ğŸ—ºï¸ ìµœì¢… ì›¨ì´í¬ì¸íŠ¸ ê°œìˆ˜:", waypoints.length);
                
                if (waypoints.length > 0) {
                    drawRoute(waypoints);
                    drawWaypointMarkers(waypoints);
                    sendWaypointsToROS();
                    document.getElementById("status").innerText = "ğŸš— ê²½ë¡œ ì„¤ì • ì™„ë£Œ! ììœ¨ì£¼í–‰ì„ ì‹œì‘í•©ë‹ˆë‹¤.";
                } else {
                    console.error("âŒ ì¶”ì¶œëœ waypointsê°€ ì—†ìŠµë‹ˆë‹¤!");
                    document.getElementById("status").innerText = "ì›¨ì´í¬ì¸íŠ¸ë¥¼ ì¶”ì¶œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
                }
            })
            .catch(error => {
                console.error("âŒ ê²½ë¡œ ë°ì´í„° ìš”ì²­ ì‹¤íŒ¨:", error);
                document.getElementById("status").innerText = "ê²½ë¡œ ìš”ì²­ ì‹¤íŒ¨. ë‹¤ì‹œ ì‹œë„í•´ì£¼ì„¸ìš”.";
            });
        }

        function sendWaypointsToROS() {
            if (waypoints.length === 0) {
                console.error("âŒ ì „ì†¡í•  Waypoints ë°ì´í„°ê°€ ì—†ìŠµë‹ˆë‹¤.");
                return;
            }

            var destinationData = destinationLatLng
                ? { lat: destinationLatLng.getLat(), lon: destinationLatLng.getLng() }
                : null;

            var waypointsData = {
                waypoints: waypoints.map(wp => ({ lat: wp.getLat(), lon: wp.getLng() })),
                destination: destinationData
            };

            if (waypointsWs && waypointsWs.readyState === WebSocket.OPEN) {
                waypointsWs.send(JSON.stringify(waypointsData));
                console.log("ğŸ“¡ Waypoints & ëª©ì ì§€ ë°ì´í„° ì „ì†¡ë¨:", waypointsData);
            } else {
                console.error("âŒ Waypoints WebSocketì´ ë‹«í˜€ ìˆìŠµë‹ˆë‹¤.");
                document.getElementById("status").innerText = "ì—°ê²° ì˜¤ë¥˜: Waypoints ì „ì†¡ ì‹¤íŒ¨";
            }
        }

        function drawRoute(coords) {
            if (routePolyline) routePolyline.setMap(null);
            routePolyline = new kakao.maps.Polyline({
                path: coords,
                strokeWeight: 5,
                strokeColor: '#FF0000',
                strokeOpacity: 0.8,
                strokeStyle: 'solid',
                map: map
            });
        }

        function drawWaypointMarkers(coords) {
            waypointMarkers.forEach(function(marker) {
                marker.setMap(null);
            });
            waypointMarkers = [];

            coords.forEach(function(coord, index) {
                var marker = new kakao.maps.Marker({
                    position: coord,
                    map: map,
                    title: `ì›¨ì´í¬ì¸íŠ¸ ${index + 1}`,
                    image: new kakao.maps.MarkerImage(
                        "https://t1.daumcdn.net/localimg/localimages/07/mapapidoc/markerStar.png",
                        new kakao.maps.Size(24, 35)
                    )
                });
                waypointMarkers.push(marker);
            });
        }

        function checkWaypointPass(lat, lon) {
            if (waypoints.length === 0 || currentWaypointIndex >= waypoints.length) return;

            let waypoint = waypoints[currentWaypointIndex];
            let distance = haversineDistance(lat, lon, waypoint.getLat(), waypoint.getLng());

            if (distance < 10) { // âœ… 10m ì„ê³„ê°’ìœ¼ë¡œ ì¡°ì •
                console.log("ğŸŸ¢ ì›¨ì´í¬ì¸íŠ¸ í†µê³¼:", currentWaypointIndex);

                waypointMarkers[currentWaypointIndex].setMap(null);

                if (currentWaypointIndex > 0) {
                    passedPolyline.setPath([...passedPolyline.getPath(), waypoints[currentWaypointIndex]]);
                } else {
                    passedPolyline.setPath([waypoints[currentWaypointIndex]]);
                }

                currentWaypointIndex++;

                let progress = Math.floor((currentWaypointIndex / waypoints.length) * 100);
                if (progress > 100) progress = 100;

                if (currentWaypointIndex >= waypoints.length) {
                    document.getElementById("status").innerText = "ğŸ‰ ëª©ì ì§€ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤!";
                } else {
                    document.getElementById("status").innerText = `ğŸš— ììœ¨ì£¼í–‰ ì§„í–‰ë¥ : ${progress}% (${currentWaypointIndex}/${waypoints.length})`;
                }

                console.log("ğŸ“Š ì§„í–‰ë¥ :", progress, "%");
            }
        }

        function haversineDistance(lat1, lon1, lat2, lon2) {
            const R = 6371000;
            const toRad = degree => degree * Math.PI / 180;
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
                Math.sin(dLon / 2) * Math.sin(dLon / 2);
            return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
        }

        // ğŸ“ ê°ë„ ê¸°ë°˜ í•„í„°ë§ í•¨ìˆ˜ë“¤
        function calculateBearing(lat1, lon1, lat2, lon2) {
            const toRad = degree => degree * Math.PI / 180;
            const toDeg = radian => radian * 180 / Math.PI;
            const dLon = toRad(lon2 - lon1);
            const lat1Rad = toRad(lat1);
            const lat2Rad = toRad(lat2);
            
            const y = Math.sin(dLon) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);
            
            let bearing = toDeg(Math.atan2(y, x));
            return (bearing + 360) % 360; // 0-360ë„ë¡œ ì •ê·œí™”
        }

        function calculateAngleDifference(bearing1, bearing2) {
            let diff = Math.abs(bearing1 - bearing2);
            if (diff > 180) diff = 360 - diff;
            return diff;
        }

        function calculateCurvature(p1, p2, p3) {
            // ê°œì„ ëœ ê³¡ë¥  ê³„ì‚°: ê°ë„ ë³€í™”ìœ¨ / ê±°ë¦¬ (ì›í˜• ê³¡ì„  ìµœì í™”)
            const bearing1 = calculateBearing(p1.getLat(), p1.getLng(), p2.getLat(), p2.getLng());
            const bearing2 = calculateBearing(p2.getLat(), p2.getLng(), p3.getLat(), p3.getLng());
            const angleDiff = calculateAngleDifference(bearing1, bearing2);
            
            // ê±°ë¦¬ ì •ë³´ë¥¼ í¬í•¨í•œ ê³¡ë¥  ê³„ì‚°
            const dist1 = haversineDistance(p1.getLat(), p1.getLng(), p2.getLat(), p2.getLng());
            const dist2 = haversineDistance(p2.getLat(), p2.getLng(), p3.getLat(), p3.getLng());
            const avgDistance = (dist1 + dist2) / 2;
            
            // ì›í˜• ê³¡ì„  ê°ì§€ë¥¼ ìœ„í•œ ê°€ì¤‘ì¹˜ ì ìš©
            if (avgDistance < 5) {
                // ë§¤ìš° ê°€ê¹Œìš´ ì ë“¤ì€ ê°ë„ ë³€í™”ì— ë” ë¯¼ê°
                return angleDiff * 2;
            } else if (avgDistance > 20) {
                // ë¨¼ ê±°ë¦¬ì˜ ì ë“¤ì€ ê³¡ë¥  ê°€ì¤‘ì¹˜ ì¦ê°€ (ì›í˜• ê³¡ì„  ê°ì§€ í–¥ìƒ)
                return angleDiff * (1 + avgDistance / 50);
            }
            
            return angleDiff;
        }

        // ğŸ¯ Douglas-Peucker ë¼ì¸ ê°„ì†Œí™” ì•Œê³ ë¦¬ì¦˜
        function perpendicularDistance(point, lineStart, lineEnd) {
            // ì ê³¼ ì§ì„  ì‚¬ì´ì˜ ìˆ˜ì§ ê±°ë¦¬ ê³„ì‚°
            const A = lineEnd.getLat() - lineStart.getLat();
            const B = lineStart.getLng() - lineEnd.getLng();
            const C = lineEnd.getLng() * lineStart.getLat() - lineStart.getLng() * lineEnd.getLat();
            
            const distance = Math.abs(A * point.getLng() + B * point.getLat() + C) / Math.sqrt(A * A + B * B);
            return distance * 111320; // ë„ë¥¼ ë¯¸í„°ë¡œ ë³€í™˜ (ëŒ€ëµì )
        }

        function douglasPeucker(points, epsilon) {
            if (points.length <= 2) return points;
            
            // ì²« ë²ˆì§¸ì™€ ë§ˆì§€ë§‰ ì  ì‚¬ì´ì˜ ì§ì„ ì„ ê¸°ì¤€ìœ¼ë¡œ ê°€ì¥ ë¨¼ ì  ì°¾ê¸°
            let maxDistance = 0;
            let maxIndex = 0;
            
            for (let i = 1; i < points.length - 1; i++) {
                const distance = perpendicularDistance(points[i], points[0], points[points.length - 1]);
                if (distance > maxDistance) {
                    maxDistance = distance;
                    maxIndex = i;
                }
            }
            
            // ìµœëŒ€ ê±°ë¦¬ê°€ ì„ê³„ê°’ë³´ë‹¤ í¬ë©´ ì¬ê·€ì ìœ¼ë¡œ ê°„ì†Œí™”
            if (maxDistance > epsilon) {
                const leftPart = douglasPeucker(points.slice(0, maxIndex + 1), epsilon);
                const rightPart = douglasPeucker(points.slice(maxIndex), epsilon);
                
                // ì¤‘ë³µ ì  ì œê±°í•˜ê³  í•©ì¹˜ê¸°
                return leftPart.slice(0, -1).concat(rightPart);
            } else {
                // ì„ê³„ê°’ë³´ë‹¤ ì‘ìœ¼ë©´ ì‹œì‘ì ê³¼ ëì ë§Œ ë°˜í™˜
                return [points[0], points[points.length - 1]];
            }
        }

        kakao.maps.event.addListener(map, 'click', function(mouseEvent) {
            var clickedPosition = mouseEvent.latLng;

            if (destinationMarker) {
                destinationMarker.setPosition(clickedPosition);
            } else {
                destinationMarker = new kakao.maps.Marker({
                    position: clickedPosition,
                    map: map,
                    title: "ëª©ì ì§€"
                });
            }

            destinationLatLng = clickedPosition;
            console.log("ğŸ¯ ëª©ì ì§€ ì„ íƒ:", clickedPosition.getLat(), clickedPosition.getLng());

            document.getElementById("status").innerText = "í´ë¦­í•œ ìœ„ì¹˜ë¡œ ê²½ë¡œ ê³„ì‚° ì¤‘...";

            if (currentMarker) {
                getRouteData(currentMarker.getPosition(), destinationLatLng);
            } else {
                alert("í˜„ì¬ ìœ„ì¹˜ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. GPSë¥¼ í™•ì¸í•´ì£¼ì„¸ìš”.");
                document.getElementById("status").innerText = "í˜„ì¬ ìœ„ì¹˜ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.";
            }
        });

        function connectWebSocket() {
            ws = new WebSocket("ws://localhost:8765");

            ws.onopen = function () {
                console.log("âœ… GPS WebSocket ì—°ê²° ì„±ê³µ!");
                document.getElementById("status").innerText = "ğŸ“¡ GPS ì—°ê²°ë¨. ëª©ì ì§€ë¥¼ í´ë¦­í•´ì£¼ì„¸ìš”.";
                connectWaypointsWebSocket();
            };

            ws.onmessage = function (event) {
                try {
                    var data = JSON.parse(event.data);
                    if (data.latitude && data.longitude) {
                        updateLocation(data.latitude, data.longitude);
                    } else {
                        console.warn("âš ï¸ GPS ë°ì´í„°ê°€ ì˜¬ë°”ë¥´ì§€ ì•ŠìŠµë‹ˆë‹¤:", data);
                    }
                } catch (error) {
                    console.error("âŒ GPS ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜:", error);
                }
            };

            ws.onerror = function (error) {
                console.error("âŒ GPS WebSocket ì˜¤ë¥˜:", error);
                document.getElementById("status").innerText = "GPS ì—°ê²° ì˜¤ë¥˜";
            };

            ws.onclose = function () {
                console.warn("âš ï¸ GPS WebSocket ì—°ê²° ì¢…ë£Œë¨. 5ì´ˆ í›„ ì¬ì—°ê²° ì‹œë„...");
                document.getElementById("status").innerText = "GPS ì—°ê²° ëŠê¹€. ì¬ì—°ê²° ì¤‘...";
                setTimeout(connectWebSocket, 5000);
            };
        }

        function connectWaypointsWebSocket() {
            if (waypointsWs && (waypointsWs.readyState === WebSocket.OPEN || waypointsWs.readyState === WebSocket.CONNECTING)) {
                console.log("âš ï¸ Waypoints WebSocket ì´ë¯¸ ì—°ê²°ë¨.");
                return;
            }

            waypointsWs = new WebSocket("ws://localhost:8766");

            waypointsWs.onopen = function () {
                console.log("âœ… Waypoints WebSocket ì—°ê²° ì„±ê³µ!");
            };

            waypointsWs.onerror = function (error) {
                console.error("âŒ Waypoints WebSocket ì˜¤ë¥˜:", error);
            };

            waypointsWs.onclose = function () {
                console.warn("âš ï¸ Waypoints WebSocket ì—°ê²° ì¢…ë£Œë¨. 5ì´ˆ í›„ ì¬ì—°ê²° ì‹œë„...");
                setTimeout(connectWaypointsWebSocket, 5000);
            };
        }

        // âœ… ì´ˆê¸° WebSocket ì—°ê²° ì‹œì‘
        connectWebSocket();
    </script>
</body>
</html>